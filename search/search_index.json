{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Space Physics Data Tutorials","text":"<p>Welcome to the documentation site of the tutorials hosted in this repository!</p> <p>Additional information found through the links on the left. Feel free to contact me with questions (tamarervin@berkeley.edu)</p>"},{"location":"#tutorials","title":"Tutorials","text":"<ul> <li>Parker Data Acquisition using pySPEDAS</li> <li>Solar Orbiter Data Acquisition using sunpy-soar</li> <li>MAVEN In Situ Data Acquisition using pySPEDAS</li> <li>MAVEN IUVS Data Acquisition using the MAVEN IUVS package</li> <li>SDO Data Acquisition using Sunpy</li> </ul>"},{"location":"setup/","title":"Setup","text":"<p>Repository containing tutorials on how to access and do basic analysis of a variety of Space Physics datasets. We primarily use the [pySPEDAS] package for data acquisition. Below are instructions for setting up the repository and conda environment.</p>"},{"location":"setup/#cloning-repository","title":"Cloning Repository","text":"<p>To get started, clone this repository to your computer. You will need to have git installed on your computer. Next, navigate (in git-bash (Windows) or Terminal (Mac/Unix/Linux)) to the location on your computer you want to save the repository.</p> <p>You can either clone via SSH after following the steps in section Setting Up an SSH Key  (tested in terminal Unix/Linux)</p> <pre><code>git clone git@github.com:tamarervin/tutorials.git\n</code></pre> <p>In Windows, if the ssh step doesn't work, use the https cloning method instead in git-bash :</p> <pre><code>git clone https://github.com/tamarervin/tutorials.git   \n</code></pre>"},{"location":"setup/#setting-up-an-ssh-key","title":"Setting Up an SSH Key","text":"<p>To clone a repository (including submodules) via SSH, you need to add a public/private SSH key to your GitHub account: * 1.) <code>cd ~/.ssh</code>     * navigate to the ssh folder on your computer * 2.) <code>ls -l</code>     * check if you already have an ssh key which would be in a file with the <code>.pub</code> extension * 3.) <code>ssh-keygen -t rsa -b 4096</code>     * creates public/private SSH key pair saved as a private (<code>file_name</code>) and public key file (<code>file_name.pub</code>) * 4.) <code>cat .pub     * view your public key file and copy the text which starts with \"ssh-rsa\" * 5.) In your GitHub account, navigate to \"Settings\" then \"SSH and GPG Keys\". Then click \"New SSH Key\" and paste in your SSH key.     * adds the SSH key to your GitHub account"},{"location":"setup/#environment-setup","title":"Environment Setup","text":"<p>This repository requires a custom environment. Do the following in Anaconda Prompt (windows), Terminal (Mac/Unic/Linux) (or use the GUI in Anaconda Navigator (Windows/Mac) Check for conda-forge:</p> <pre><code>conda config --show channels\n</code></pre> <p>If needed, add conda-forge:</p> <pre><code>conda config --append channels conda-forge\n</code></pre> <p>Now we are ready to build the custom conda environment. Navigate to the folder containing the configuration file and run the below snippet.</p> <pre><code>conda env create --file conda_env.yml\n</code></pre> <p>To activate the conda environment run</p> <pre><code>conda activate analysis\n</code></pre>"},{"location":"setup/#maven-iuvs-setup","title":"MAVEN IUVS Setup","text":"<p>In order to use the MAVEN IUVS package, it must be in this repository as a submodule.</p> <p>Setup the MAVEN IUVS submodule:  * 1.) <code>git submodule init</code>     * initiates the submodule instance found in the .gitmodules file * 2.) <code>git submodule update</code>     * updates and clones the MAVEN IUVS repository * 3.) <code>pip install -e .</code>     * navigate to the MAVEN IUVS directory and pip install the package</p>"},{"location":"examples/docs_iuvs/","title":"IUVS Data","text":"In\u00a0[103]: Copied! <pre>import maven_iuvs.download as dnld\nimport maven_iuvs.search as search\nfrom astropy.io import fits\nimport matplotlib.pyplot as plt\nimport glob\n</pre> import maven_iuvs.download as dnld import maven_iuvs.search as search from astropy.io import fits import matplotlib.pyplot as plt import glob In\u00a0[\u00a0]: Copied! <pre>import os, sys\nsys.path.append('maven_iuvs')\n\ndnld.get_euvm_l2b_dir()\n</pre> import os, sys sys.path.append('maven_iuvs')  dnld.get_euvm_l2b_dir() In\u00a0[111]: Copied! <pre>### READ IN FILES WITH ASTROPY FITS\nfiles = glob.glob(os.path.join(os.path.realpath(os.path.join('limb_derived_2022', 'l2/limb/2022/01')), \"*.fits\"), recursive=True)\n\nhdul = fits.open(files[5]) ### READ IN FIRST FITS FILE\n\n### PRINT OUT FILE INFO\nprint(hdul.info())\n</pre> ### READ IN FILES WITH ASTROPY FITS files = glob.glob(os.path.join(os.path.realpath(os.path.join('limb_derived_2022', 'l2/limb/2022/01')), \"*.fits\"), recursive=True)  hdul = fits.open(files[5]) ### READ IN FIRST FITS FILE  ### PRINT OUT FILE INFO print(hdul.info()) <pre>Filename: /Users/tamarervin/orestis-maven/limb_derived_2022/l2/limb/2022/01/mvn_iuv_l2_periapse-orbit15541_20220107T092059_v13_r01.fits\nNo.    Name      Ver    Type      Cards   Dimensions   Format\n  0  PRIMARY       1 PrimaryHDU      16   ()      \n  1  SPECIES       1 BinTableHDU     21   3R x 1C   [3A]   \n  2  DENSITY       1 BinTableHDU     40   14R x 4C   [57E, 57E, 57E, 57E]   \n  3  TEMPERATURE    1 BinTableHDU     38   14R x 7C   [E, E, E, 19E, 19E, 19E, 19E]   \n  4  GEOMETRY_RETRIEVAL    1 BinTableHDU     70   14R x 11C   [D, D, D, D, D, D, D, D, D, D, D]   \n  5  EMISSION_FEATURES    1 BinTableHDU     34   29R x 4C   [18A, 256D, E, E]   \n  6  MODEL_RADIANCE    1 BinTableHDU     45   14R x 6C   [37A, E, 29E, 1885E, 1885E, 1885E]   \n  7  GEOMETRY_RADIANCE    1 BinTableHDU     75   14R x 12C   [65D, 65D, 65D, 65D, 65D, 65D, 65D, 65D, 65D, 65D, 65D, 65D]   \n  8  OBSERVATION    1 BinTableHDU     63   1R x 13C   [59A, 4A, 7A, 21A, 21A, 33A, I, 5A, 4A, I, I, E, 60A]   \nNone\n</pre> In\u00a0[112]: Copied! <pre>### SPECIES DATA\nprint(hdul[1].data['ID']) ## species information\n</pre> ### SPECIES DATA print(hdul[1].data['ID']) ## species information <pre>['CO2' 'N2' 'O']\n</pre> In\u00a0[113]: Copied! <pre>### ALTITUDE DATA -- km\nCO2_altitudes = hdul[2].data['ALT'][0][:, 0]\nN2_altitudes = hdul[2].data['ALT'][0][:, 1]\nO_altitudes = hdul[2].data['ALT'][0][:, 2]\n\n### DENSITY DATA -- cm^{-3}\nCO2_density = hdul[2].data['PROFILE'][0][:, 0]\nN2_density = hdul[2].data['PROFILE'][0][:, 1]\nO_density = hdul[2].data['PROFILE'][0][:, 2]\n</pre> ### ALTITUDE DATA -- km CO2_altitudes = hdul[2].data['ALT'][0][:, 0] N2_altitudes = hdul[2].data['ALT'][0][:, 1] O_altitudes = hdul[2].data['ALT'][0][:, 2]  ### DENSITY DATA -- cm^{-3} CO2_density = hdul[2].data['PROFILE'][0][:, 0] N2_density = hdul[2].data['PROFILE'][0][:, 1] O_density = hdul[2].data['PROFILE'][0][:, 2] In\u00a0[114]: Copied! <pre>fig = plt.figure(figsize=[8, 6])\nplt.scatter(CO2_density, CO2_altitudes, color='red', label='$CO_2$') \nplt.scatter(N2_density, N2_altitudes, color='blue', label='$N_2$')\nplt.scatter(O_density, O_altitudes, color='green', label='$O$')\nplt.legend(loc='upper right', fontsize=16)\nplt.xlabel('Density [cm$^{-3}$]', fontsize=16)\nplt.ylabel('Altitude [km]', fontsize=16)\n</pre> fig = plt.figure(figsize=[8, 6]) plt.scatter(CO2_density, CO2_altitudes, color='red', label='$CO_2$')  plt.scatter(N2_density, N2_altitudes, color='blue', label='$N_2$') plt.scatter(O_density, O_altitudes, color='green', label='$O$') plt.legend(loc='upper right', fontsize=16) plt.xlabel('Density [cm$^{-3}$]', fontsize=16) plt.ylabel('Altitude [km]', fontsize=16) Out[114]: <pre>Text(0, 0.5, 'Altitude [km]')</pre> In\u00a0[117]: Copied! <pre>### TEMPERATURE DATA\ntemperature = hdul[3].data['PROFILE'] ## temperature in Kelvin\ntemperature_altitudes = hdul[3].data['ALT'] ## altitude of temperature\n\n### PLOT TEMPERATURE PROFILE\n</pre> ### TEMPERATURE DATA temperature = hdul[3].data['PROFILE'] ## temperature in Kelvin temperature_altitudes = hdul[3].data['ALT'] ## altitude of temperature  ### PLOT TEMPERATURE PROFILE  In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/docs_iuvs/#using-the-iuvs-package","title":"Using the IUVS Package\u00b6","text":"<p>The IUVS instrument has its own Python package for reading in files</p>"},{"location":"examples/docs_maven/","title":"MAVEN Data","text":"In\u00a0[\u00a0]: Copied! <pre>import glob\nimport pyspedas\nimport cdflib\nimport sunpy\nimport astrospice\nimport sunpy \nimport sys, os\nimport datetime\nimport numpy as np\nimport pandas as pd\nimport astropy.units as u\nimport matplotlib.pyplot as plt\n</pre> import glob import pyspedas import cdflib import sunpy import astrospice import sunpy  import sys, os import datetime import numpy as np import pandas as pd import astropy.units as u import matplotlib.pyplot as plt In\u00a0[\u00a0]: Copied! <pre>### ------- TIME PERIOD OF INTEREST ------- ###\ntime_range = ['2021-08-10', '2021-08-11']\n</pre> ### ------- TIME PERIOD OF INTEREST ------- ### time_range = ['2021-08-10', '2021-08-11'] <p>We start by using pyspedas to pull the MAVEN MAG data. There are some weird things with these files so we have to use some other functions to actually read in the files.</p> In\u00a0[\u00a0]: Copied! <pre>### ------- MAVEN: MAG RTN DATA ------- ###\npyspedas.maven.mag(trange=time_range, datatype='ss1s', downloadonly=True)\n</pre> ### ------- MAVEN: MAG RTN DATA ------- ### pyspedas.maven.mag(trange=time_range, datatype='ss1s', downloadonly=True)  <p>These are the functions to read in the MAVEN MAG files.</p> <p>Courtesy of Rebecca Jolitz.</p> In\u00a0[\u00a0]: Copied! <pre>import datetime as dt\ndef read_sts(filename, method='loadtxt'):\n\n    if \"mvn_mag_ql\" in filename:\n        skip_header = 86\n    elif \"mvn_mag_l2\" in filename:\n        skip_header = 150\n\n    if method == \"loadtxt\":\n        b = np.loadtxt(filename, skiprows=skip_header, dtype='f8')\n    elif method == \"genfromtxt\":\n        b = np.genfromtxt(\n            filename,\n            delimiter=(6, 4, 3, 3, 3, 4, 14, 11, 10, 10, 4),\n            skip_header=skip_header, dtype='f8')\n\n    return b\n\ndef doy_to_utc(year, doy, hour, minute, sec, msec):\n\n    # Sometimes these fields are\n    # improperly read as integers,\n    # which will cause strange additive behaviors.\n    # Convert them to floats to avoid this.\n    year = year.astype('float')\n    doy = doy.astype('float')\n    hour = hour.astype('float')\n    minute = minute.astype('float')\n    sec = sec.astype('float')\n    msec = msec.astype('float')\n\n    # Get the total number of seconds that have transpired\n    # since the year started.\n    total_sec = (doy - 1)*24*60*60 + hour*60*60 +\\\n        minute*60 + sec + (1e-3*msec)\n    time_utc =\\\n        [dt.datetime(int(y), 1, 1) + dt.timedelta(seconds=s) for (y, s) in\n         zip(year, total_sec)]\n\n    return time_utc\n\n\ndef parse_sts(b, columns=(\"epoch\", \"Bx\", \"By\", \"Bz\")):\n\n    # L1 has 11 columns:\n    # Year | DOY | Hour | Min | Sec | Msec | Decimal day |\n    # (Outboard magnetic field columns)\n    # OB_B_X (nT)| OB_B_Y (nT)| OB_B_Z (nT)| OB_B_RANGE (nT)|\n\n    # L2 has 18 columns:\n    # Year | DOY | Hour | Min | Sec | Msec | Decimal day |\n    # (Outboard magnetic field columns)\n    # OB_B_X (nT)| OB_B_Y (nT)| OB_B_Z (nT)| OB_B_RANGE (nT)|\n    # (S/c position columns)\n    # POSN_X (km) | POSN_Y (km) | POSN_Z (km)\n    # (Outboard dynamic corrections)\n    # OB (nT)| OB_BD_Y (nT)| OB_BD_Z (nT)| OB_BD_RANGE (nT)|\n\n    time_utc = doy_to_utc(b[:, 0], b[:, 1], b[:, 2], b[:, 3], b[:, 4], b[:, 5])\n\n    bx = b[:, 7]\n    by = b[:, 8]\n    bz = b[:, 9]\n\n    return time_utc, bx, by, bz\n</pre> import datetime as dt def read_sts(filename, method='loadtxt'):      if \"mvn_mag_ql\" in filename:         skip_header = 86     elif \"mvn_mag_l2\" in filename:         skip_header = 150      if method == \"loadtxt\":         b = np.loadtxt(filename, skiprows=skip_header, dtype='f8')     elif method == \"genfromtxt\":         b = np.genfromtxt(             filename,             delimiter=(6, 4, 3, 3, 3, 4, 14, 11, 10, 10, 4),             skip_header=skip_header, dtype='f8')      return b  def doy_to_utc(year, doy, hour, minute, sec, msec):      # Sometimes these fields are     # improperly read as integers,     # which will cause strange additive behaviors.     # Convert them to floats to avoid this.     year = year.astype('float')     doy = doy.astype('float')     hour = hour.astype('float')     minute = minute.astype('float')     sec = sec.astype('float')     msec = msec.astype('float')      # Get the total number of seconds that have transpired     # since the year started.     total_sec = (doy - 1)*24*60*60 + hour*60*60 +\\         minute*60 + sec + (1e-3*msec)     time_utc =\\         [dt.datetime(int(y), 1, 1) + dt.timedelta(seconds=s) for (y, s) in          zip(year, total_sec)]      return time_utc   def parse_sts(b, columns=(\"epoch\", \"Bx\", \"By\", \"Bz\")):      # L1 has 11 columns:     # Year | DOY | Hour | Min | Sec | Msec | Decimal day |     # (Outboard magnetic field columns)     # OB_B_X (nT)| OB_B_Y (nT)| OB_B_Z (nT)| OB_B_RANGE (nT)|      # L2 has 18 columns:     # Year | DOY | Hour | Min | Sec | Msec | Decimal day |     # (Outboard magnetic field columns)     # OB_B_X (nT)| OB_B_Y (nT)| OB_B_Z (nT)| OB_B_RANGE (nT)|     # (S/c position columns)     # POSN_X (km) | POSN_Y (km) | POSN_Z (km)     # (Outboard dynamic corrections)     # OB (nT)| OB_BD_Y (nT)| OB_BD_Z (nT)| OB_BD_RANGE (nT)|      time_utc = doy_to_utc(b[:, 0], b[:, 1], b[:, 2], b[:, 3], b[:, 4], b[:, 5])      bx = b[:, 7]     by = b[:, 8]     bz = b[:, 9]      return time_utc, bx, by, bz In\u00a0[\u00a0]: Copied! <pre>### READ IN TEXT FILES\nmag_file_path = glob.glob(os.path.realpath(os.path.join('maven_data/maven/data/sci', 'mag/l2', '2021', '08', '*.sts'))) ## path to the .sts magnetic field files\ntime_utc, bx, by, bz = parse_sts(read_sts(mag_file_path[1])) ## read in a specific file\n\n### CALCULATE THE MAGNETIC FIELD MAGNITUDE\nBtotal = np.sqrt(bx**2 + by**2 + bz**2)\n</pre> ### READ IN TEXT FILES mag_file_path = glob.glob(os.path.realpath(os.path.join('maven_data/maven/data/sci', 'mag/l2', '2021', '08', '*.sts'))) ## path to the .sts magnetic field files time_utc, bx, by, bz = parse_sts(read_sts(mag_file_path[1])) ## read in a specific file  ### CALCULATE THE MAGNETIC FIELD MAGNITUDE Btotal = np.sqrt(bx**2 + by**2 + bz**2)  <p>We now plot the x, y, z and total magnetic field!</p> In\u00a0[\u00a0]: Copied! <pre>### PLOT THE MAG DATA\nfig = plt.figure(figsize=[15, 4])\nplt.plot(time_utc, bx, color='tab:blue', label=r'$\\rm B_x$')\nplt.plot(time_utc, by, color='tab:red', label=r'$\\rm B_y$')\nplt.plot(time_utc, bz, color='tab:green', label=r'$\\rm B_z$')\nplt.plot(time_utc, Btotal, color='black', label=r'$\\rm |B|$')\nplt.ylabel(r'$\\rm B \\; [nT]$')\nplt.legend(loc='upper right', fontsize=18)\n</pre> ### PLOT THE MAG DATA fig = plt.figure(figsize=[15, 4]) plt.plot(time_utc, bx, color='tab:blue', label=r'$\\rm B_x$') plt.plot(time_utc, by, color='tab:red', label=r'$\\rm B_y$') plt.plot(time_utc, bz, color='tab:green', label=r'$\\rm B_z$') plt.plot(time_utc, Btotal, color='black', label=r'$\\rm |B|$') plt.ylabel(r'$\\rm B \\; [nT]$') plt.legend(loc='upper right', fontsize=18) <p>Now we will look at some particle data!</p> In\u00a0[\u00a0]: Copied! <pre>### ------- SWIA: ION MOMENTS ------- ###\n### download ion particle data\npyspedas.maven.swia(trange=time_range, datatype='onboardsvymom', downloadonly=True)\n</pre> ### ------- SWIA: ION MOMENTS ------- ### ### download ion particle data pyspedas.maven.swia(trange=time_range, datatype='onboardsvymom', downloadonly=True)  <p>We will use a special CDF reader to read in the files.</p> In\u00a0[\u00a0]: Copied! <pre>### READ IN THE ION (SWIA) FILES\nfiles = glob.glob(os.path.join(os.path.realpath(os.path.join('maven_data', 'maven/data/sci/swi/l2/2021/08')), \"*.cdf\"), recursive=True)\ndata_cdf = cdflib.CDF(files[0]) ## read in the first ion file\n\n### PRINT OUT FILE INFO\nprint(data_cdf.cdf_info())\n\n### READ IN VARIABLE INFO\nN = data_cdf.varget(\"density\")\nv = data_cdf.varget(\"velocity\")\nT = data_cdf.varget(\"temperature\")\np = data_cdf.varget(\"pressure\")\n\n### PLOT THE DATA\nfig, axs = plt.subplots(4, figsize=[14, 10])\ndt = [N, v, T, p]\nylabels = [r'$\\rm N_p$', r'$\\rm v_p$', r'$\\rm T_p$', r'$\\rm p_p$']\nfor i, ax in enumerate(axs):\n    ax.plot(dt[i], linewidth=1)\n    ax.set_ylabel(ylabels[i], fontsize=16)\n</pre> ### READ IN THE ION (SWIA) FILES files = glob.glob(os.path.join(os.path.realpath(os.path.join('maven_data', 'maven/data/sci/swi/l2/2021/08')), \"*.cdf\"), recursive=True) data_cdf = cdflib.CDF(files[0]) ## read in the first ion file  ### PRINT OUT FILE INFO print(data_cdf.cdf_info())  ### READ IN VARIABLE INFO N = data_cdf.varget(\"density\") v = data_cdf.varget(\"velocity\") T = data_cdf.varget(\"temperature\") p = data_cdf.varget(\"pressure\")  ### PLOT THE DATA fig, axs = plt.subplots(4, figsize=[14, 10]) dt = [N, v, T, p] ylabels = [r'$\\rm N_p$', r'$\\rm v_p$', r'$\\rm T_p$', r'$\\rm p_p$'] for i, ax in enumerate(axs):     ax.plot(dt[i], linewidth=1)     ax.set_ylabel(ylabels[i], fontsize=16) <p>Read in the EUV Data</p> In\u00a0[\u00a0]: Copied! <pre>files = glob.glob(os.path.join(os.path.realpath(os.path.join('maven_data', 'maven/data/sci/euv/l2/2016/01')), \"*\"), recursive=True)\ndata_cdf = cdflib.CDF(files[0]) ## read in the first EUV file\n\n### PRINT OUT FILE INFO\nprint(data_cdf.cdf_info())\n\n### Get the spectral irradiance (W/m^2) as a timeseries\ndt = data_cdf.varget(\"data\")\ntime = data_cdf.varget(\"time_unix\")\n\n### PLOT THE SPECTRAL IRRANDIANCE\nfig = plt.figure(figsize=[15, 4])\nplt.plot(time, dt)\nplt.ylabel('Spectral Irradiance')\n</pre> files = glob.glob(os.path.join(os.path.realpath(os.path.join('maven_data', 'maven/data/sci/euv/l2/2016/01')), \"*\"), recursive=True) data_cdf = cdflib.CDF(files[0]) ## read in the first EUV file  ### PRINT OUT FILE INFO print(data_cdf.cdf_info())  ### Get the spectral irradiance (W/m^2) as a timeseries dt = data_cdf.varget(\"data\") time = data_cdf.varget(\"time_unix\")  ### PLOT THE SPECTRAL IRRANDIANCE fig = plt.figure(figsize=[15, 4]) plt.plot(time, dt) plt.ylabel('Spectral Irradiance')"},{"location":"examples/docs_maven/#maven-data-access-example","title":"MAVEN Data Access Example\u00b6","text":"<p>Tamar Ervin</p> <p>September 21, 2023</p> <ul> <li>Downloading MAVEN data with PySPEDAS</li> <li>PySPEDAS is unable to read the CDF files, so it will break with the CDF reader but still download the files!</li> </ul>"},{"location":"examples/docs_maven/#download-and-plot-the-data","title":"Download and Plot the Data\u00b6","text":""},{"location":"examples/docs_orbiter/","title":"Orbiter Data","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nfrom matplotlib import dates\nimport numpy as np\nimport pandas as pd\nfrom sunpy.net import Fido, attrs as a \nfrom sunpy.coordinates import frames, get_horizons_coord, get_body_heliographic_stonyhurst\nfrom sunpy.time import parse_time\nimport sunpy.map\nimport sunpy.timeseries\nimport sunpy_soar\nfrom astropy import units as u \nfrom astropy.coordinates import SkyCoord\nfrom astropy.visualization import PowerStretch, AsinhStretch, LogStretch\nfrom astropy.wcs import WCS\nfrom astropy.visualization.mpl_normalize import ImageNormalize\nfrom astropy import constants as const\nfrom astropy.time import Time\nfrom reproject.mosaicking import reproject_and_coadd\nfrom reproject import reproject_interp\nfrom pytplot import tplot, get_data, cdf_to_tplot, store_data\nimport glob\nimport pyspedas\nimport datetime\nimport astrospice\nfor sc in ['psp','solar orbiter'] : kernels = astrospice.registry.get_kernels(sc,'predict') \nfrom scipy.interpolate import interp1d\n</pre> import matplotlib.pyplot as plt from matplotlib import dates import numpy as np import pandas as pd from sunpy.net import Fido, attrs as a  from sunpy.coordinates import frames, get_horizons_coord, get_body_heliographic_stonyhurst from sunpy.time import parse_time import sunpy.map import sunpy.timeseries import sunpy_soar from astropy import units as u  from astropy.coordinates import SkyCoord from astropy.visualization import PowerStretch, AsinhStretch, LogStretch from astropy.wcs import WCS from astropy.visualization.mpl_normalize import ImageNormalize from astropy import constants as const from astropy.time import Time from reproject.mosaicking import reproject_and_coadd from reproject import reproject_interp from pytplot import tplot, get_data, cdf_to_tplot, store_data import glob import pyspedas import datetime import astrospice for sc in ['psp','solar orbiter'] : kernels = astrospice.registry.get_kernels(sc,'predict')  from scipy.interpolate import interp1d <pre>Files Downloaded:   0%|          | 0/1 [00:00&lt;?, ?file/s]</pre> <pre>03-Nov-23 12:23:28: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/erfa/core.py:154: ErfaWarning: ERFA function \"dtf2d\" yielded 1 of \"dubious year (Note 6)\"\n  warnings.warn('ERFA function \"{}\" yielded {}'.format(func_name, wmsg),\n\n</pre> <pre>Files Downloaded:   0%|          | 0/1 [00:00&lt;?, ?file/s]</pre> In\u00a0[8]: Copied! <pre># check if necessary folders exists\nfolder_path = os.path.realpath('results')\nif not os.path.exists(folder_path):\n    os.makedirs(folder_path)\n    print(f\"Folder '{folder_path}' created.\")\nelse:\n    print(f\"Folder '{folder_path}' already exists.\")\n</pre> # check if necessary folders exists folder_path = os.path.realpath('results') if not os.path.exists(folder_path):     os.makedirs(folder_path)     print(f\"Folder '{folder_path}' created.\") else:     print(f\"Folder '{folder_path}' already exists.\") <pre>Folder '/Users/tamarervin/tutorials/results' created.\n</pre> In\u00a0[2]: Copied! <pre>### TIME RANGE OF INTEREST\ntimerange = a.Time(\"2022-02-28\", \"2022-03-03\")\n</pre> ### TIME RANGE OF INTEREST timerange = a.Time(\"2022-02-28\", \"2022-03-03\") <p>Now we construct a query to specifically search for the instrument, level, and data product that we want.</p> In\u00a0[3]: Copied! <pre>### SEARCH FOR MAG RTN DATA - L2 MAG\nmag_files = Fido.search(timerange, \n                      a.Instrument(\"MAG\"), \n                      a.Level(2), a.Provider.soar, a.soar.Product('mag-rtn-normal-1-minute'))\n### SEARCH FOR PAS PARTICLE DATA - L2 SWA\npas_files = Fido.search(timerange, \n                      a.Instrument(\"SWA\"), \n                      a.Level(2), a.Provider.soar, a.soar.Product('swa-pas-grnd-mom'))\n### SEARCH FOR HIS DATA - L3 SWA \nhis_files = Fido.search(timerange, \n                      a.Instrument(\"SWA\"), \n                      a.Level(3), a.Provider.soar)\n</pre> ### SEARCH FOR MAG RTN DATA - L2 MAG mag_files = Fido.search(timerange,                        a.Instrument(\"MAG\"),                        a.Level(2), a.Provider.soar, a.soar.Product('mag-rtn-normal-1-minute')) ### SEARCH FOR PAS PARTICLE DATA - L2 SWA pas_files = Fido.search(timerange,                        a.Instrument(\"SWA\"),                        a.Level(2), a.Provider.soar, a.soar.Product('swa-pas-grnd-mom')) ### SEARCH FOR HIS DATA - L3 SWA  his_files = Fido.search(timerange,                        a.Instrument(\"SWA\"),                        a.Level(3), a.Provider.soar) In\u00a0[4]: Copied! <pre>### DOWNLOAD MAG DATA\nmag = Fido.fetch(mag_files, path=\"./solar_orbiter_data/mag/L2/2022\")\n\n### DOWNLOAD PAS DATA\npas = Fido.fetch(pas_files, path=\"./solar_orbiter_data/swa/L2/2022\")\n\n### DOWNLOAD HIS DATA\nhis = Fido.fetch(his_files, path=\"./solar_orbiter_data/swa/L3/2022\")\n</pre> ### DOWNLOAD MAG DATA mag = Fido.fetch(mag_files, path=\"./solar_orbiter_data/mag/L2/2022\")  ### DOWNLOAD PAS DATA pas = Fido.fetch(pas_files, path=\"./solar_orbiter_data/swa/L2/2022\")  ### DOWNLOAD HIS DATA his = Fido.fetch(his_files, path=\"./solar_orbiter_data/swa/L3/2022\") <pre>Exception ignored in: &lt;function BaseEventLoop.__del__ at 0x101ddfba0&gt;\nTraceback (most recent call last):\n  File \"/Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/asyncio/base_events.py\", line 691, in __del__\n    self.close()\n  File \"/Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/asyncio/unix_events.py\", line 71, in close\n    self.remove_signal_handler(sig)\n  File \"/Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/asyncio/unix_events.py\", line 160, in remove_signal_handler\n    signal.signal(sig, handler)\n  File \"/Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/signal.py\", line 56, in signal\n    handler = _signal.signal(_enum_to_int(signalnum), _enum_to_int(handler))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nValueError: signal only works in main thread of the main interpreter\n</pre> <pre>Files Downloaded:   0%|          | 0/4 [00:00&lt;?, ?file/s]</pre> <pre>solo_L2_mag-rtn-normal-1-minute_20220303_V01.cdf:   0%|          | 0.00/32.7k [00:00&lt;?, ?B/s]</pre> <pre>solo_L2_mag-rtn-normal-1-minute_20220302_V01.cdf:   0%|          | 0.00/32.4k [00:00&lt;?, ?B/s]</pre> <pre>solo_L2_mag-rtn-normal-1-minute_20220301_V01.cdf:   0%|          | 0.00/32.5k [00:00&lt;?, ?B/s]</pre> <pre>solo_L2_mag-rtn-normal-1-minute_20220228_V01.cdf:   0%|          | 0.00/32.6k [00:00&lt;?, ?B/s]</pre> <pre>Files Downloaded:   0%|          | 0/4 [00:00&lt;?, ?file/s]</pre> <pre>solo_L2_swa-pas-grnd-mom_20220302_V02.cdf:   0%|          | 0.00/3.33M [00:00&lt;?, ?B/s]</pre> <pre>solo_L2_swa-pas-grnd-mom_20220301_V02.cdf:   0%|          | 0.00/2.70M [00:00&lt;?, ?B/s]</pre> <pre>solo_L2_swa-pas-grnd-mom_20220303_V02.cdf:   0%|          | 0.00/3.25M [00:00&lt;?, ?B/s]</pre> <pre>solo_L2_swa-pas-grnd-mom_20220228_V02.cdf:   0%|          | 0.00/2.70M [00:00&lt;?, ?B/s]</pre> <pre>Files Downloaded:   0%|          | 0/4 [00:00&lt;?, ?file/s]</pre> <pre>solo_L3_swa-his-comp-10min_20220302_V01.cdf:   0%|          | 0.00/253k [00:00&lt;?, ?B/s]</pre> <pre>solo_L3_swa-his-comp-10min_20220228_V01.cdf:   0%|          | 0.00/247k [00:00&lt;?, ?B/s]</pre> <pre>solo_L3_swa-his-comp-10min_20220301_V01.cdf:   0%|          | 0.00/247k [00:00&lt;?, ?B/s]</pre> <pre>solo_L3_swa-his-comp-10min_20220303_V01.cdf:   0%|          | 0.00/252k [00:00&lt;?, ?B/s]</pre> <p>Lets load in situ data into a sunpy <code>TimeSeries</code> and concatenate the files</p> In\u00a0[5]: Copied! <pre>### CREATE MAG TIMESERIES\nmag_data = sunpy.timeseries.TimeSeries(mag, concatenate=True)\n\n### CREATE MAG TIMESERIES\npas_data = sunpy.timeseries.TimeSeries(pas, concatenate=True)\n\n### CREATE MAG TIMESERIES\nhis_data = sunpy.timeseries.TimeSeries(his, concatenate=True)\n</pre> ### CREATE MAG TIMESERIES mag_data = sunpy.timeseries.TimeSeries(mag, concatenate=True)  ### CREATE MAG TIMESERIES pas_data = sunpy.timeseries.TimeSeries(pas, concatenate=True)  ### CREATE MAG TIMESERIES his_data = sunpy.timeseries.TimeSeries(his, concatenate=True) <pre>03-Nov-23 12:25:57: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:103: SunpyUserWarning: astropy did not recognize units of \"Ticks\". Assigning dimensionless units. If you think this unit should not be dimensionless, please raise an issue at https://github.com/sunpy/sunpy/issues\n  warn_user(f'astropy did not recognize units of \"{unit_str}\". '\n\n03-Nov-23 12:25:57: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:103: SunpyUserWarning: astropy did not recognize units of \"Ticks\". Assigning dimensionless units. If you think this unit should not be dimensionless, please raise an issue at https://github.com/sunpy/sunpy/issues\n  warn_user(f'astropy did not recognize units of \"{unit_str}\". '\n\n03-Nov-23 12:25:57: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:103: SunpyUserWarning: astropy did not recognize units of \"Ticks\". Assigning dimensionless units. If you think this unit should not be dimensionless, please raise an issue at https://github.com/sunpy/sunpy/issues\n  warn_user(f'astropy did not recognize units of \"{unit_str}\". '\n\n03-Nov-23 12:25:57: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:103: SunpyUserWarning: astropy did not recognize units of \"Ticks\". Assigning dimensionless units. If you think this unit should not be dimensionless, please raise an issue at https://github.com/sunpy/sunpy/issues\n  warn_user(f'astropy did not recognize units of \"{unit_str}\". '\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:58: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:25:59: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:00: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:01: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:119: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key + f'_{i}'] = col\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n03-Nov-23 12:26:02: /Users/tamarervin/miniconda3/envs/e11_conjunction/lib/python3.11/site-packages/sunpy/io/_cdf.py:123: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  df[var_key] = data\n\n</pre> <p>An example of plotting the data using the Sunpy ecosystem! This is an easy way to get a quicklook at the data.</p> In\u00a0[6]: Copied! <pre>### OVERVIEW OF DATA\nylabels=[r'$\\rm B$', r'$\\rm v_p$', r'$\\rm Abundance$']\nfig, axs = plt.subplots(3, figsize=[20, 12], sharex='all', gridspec_kw={'hspace':0})\nmag_data.plot(columns=[\"B_RTN_0\", \"B_RTN_1\", \"B_RTN_2\"], axes=axs[0])\npas_data.plot(columns=[\"V_RTN_0\", \"V_RTN_1\", \"V_RTN_2\"], axes=axs[1])\nhis_data.plot(columns=[\"C6_C4_RATIO\", \"O7_O6_RATIO\", \"FE_O_ABUN\"], axes=axs[2])\naxs[2].set_yscale('log')\nfor i, ax in enumerate(axs):\n    ax.set_ylabel(ylabels[i], fontsize=20)\n    ax.axvspan(pd.Timestamp('03/01/2022 00:00:00'), pd.Timestamp('03/01/2022 6:00:00'), zorder=-2, color='lavender')\naxs[0].set_title(r'$\\rm Solar \\; Orbiter \\; Overview$', fontsize=22)\n</pre> ### OVERVIEW OF DATA ylabels=[r'$\\rm B$', r'$\\rm v_p$', r'$\\rm Abundance$'] fig, axs = plt.subplots(3, figsize=[20, 12], sharex='all', gridspec_kw={'hspace':0}) mag_data.plot(columns=[\"B_RTN_0\", \"B_RTN_1\", \"B_RTN_2\"], axes=axs[0]) pas_data.plot(columns=[\"V_RTN_0\", \"V_RTN_1\", \"V_RTN_2\"], axes=axs[1]) his_data.plot(columns=[\"C6_C4_RATIO\", \"O7_O6_RATIO\", \"FE_O_ABUN\"], axes=axs[2]) axs[2].set_yscale('log') for i, ax in enumerate(axs):     ax.set_ylabel(ylabels[i], fontsize=20)     ax.axvspan(pd.Timestamp('03/01/2022 00:00:00'), pd.Timestamp('03/01/2022 6:00:00'), zorder=-2, color='lavender') axs[0].set_title(r'$\\rm Solar \\; Orbiter \\; Overview$', fontsize=22) Out[6]: <pre>Text(0.5, 1.0, '$\\\\rm Solar \\\\; Orbiter \\\\; Overview$')</pre> In\u00a0[9]: Copied! <pre>### SOLO MAG DATA\nmm = mag_data.to_dataframe()\nrd = {'Time': mm.index, 'Br': mm.B_RTN_0, 'Bt': mm.B_RTN_1, 'Bn': mm.B_RTN_2}\nmag = pd.DataFrame(data=rd, index=None)\nmag.to_csv(os.path.join('results', 'mag.csv'))\n</pre> ### SOLO MAG DATA mm = mag_data.to_dataframe() rd = {'Time': mm.index, 'Br': mm.B_RTN_0, 'Bt': mm.B_RTN_1, 'Bn': mm.B_RTN_2} mag = pd.DataFrame(data=rd, index=None) mag.to_csv(os.path.join('results', 'mag.csv')) In\u00a0[16]: Copied! <pre>### SOLO SWA/PAS DATA\nmm = pas_data.to_dataframe()\nrd = {'Time': mm.index, 'vr': mm.V_RTN_0, 'vt': mm.V_RTN_1, 'vn': mm.V_RTN_2, 'Np': mm.N, 'Tp': mm['T']}\npas = pd.DataFrame(data=rd)\npas.to_csv(os.path.join('results', 'pas.csv'))\n</pre> ### SOLO SWA/PAS DATA mm = pas_data.to_dataframe() rd = {'Time': mm.index, 'vr': mm.V_RTN_0, 'vt': mm.V_RTN_1, 'vn': mm.V_RTN_2, 'Np': mm.N, 'Tp': mm['T']} pas = pd.DataFrame(data=rd) pas.to_csv(os.path.join('results', 'pas.csv')) In\u00a0[17]: Copied! <pre>### SOLO SWA/HIS DATA\nmm = his_data.to_dataframe()\nrd = {'Time': mm.index, 'FeO': mm.FE_O_ABUN, 'C6C4': mm.C6_C4_RATIO, 'O7O6': mm.O7_O6_RATIO}\nhis = pd.DataFrame(data=rd)\nhis.to_csv(os.path.join('results', 'his.csv'))\n</pre> ### SOLO SWA/HIS DATA mm = his_data.to_dataframe() rd = {'Time': mm.index, 'FeO': mm.FE_O_ABUN, 'C6C4': mm.C6_C4_RATIO, 'O7O6': mm.O7_O6_RATIO} his = pd.DataFrame(data=rd) his.to_csv(os.path.join('results', 'his.csv')) <p>Now that we have a dataframe for each instrument, we will merge these dataframes as a function of time. WARNING!!! The cadence of SWA/HIS measurements is much less than the MAG &amp; SWA/PAS cadence. If you decide to incorporate HIS measurements, you should create separate dataframes so you can study different timescales of fluctuations.</p> In\u00a0[21]: Copied! <pre>### merge the PAS and MAG dataframes\nmerged_df = pd.merge_asof(pas, mag, on='Time', direction='backward')\n\n### merge the HIS and newly merged dataframe\nmerged_df = pd.merge_asof(his, merged_df, on='Time', direction='backward')\nmerged_df = merged_df.set_index('Time')\n</pre> ### merge the PAS and MAG dataframes merged_df = pd.merge_asof(pas, mag, on='Time', direction='backward')  ### merge the HIS and newly merged dataframe merged_df = pd.merge_asof(his, merged_df, on='Time', direction='backward') merged_df = merged_df.set_index('Time') In\u00a0[22]: Copied! <pre>### Create SkyCoord for Orbiter in the inertial (J2000) frame\nsolo_inertial = astrospice.generate_coords(\n    'SOLAR ORBITER', pd.to_datetime(merged_df.index.to_list())\n\n)\n\n### Transform to solar co-rotating frame \nsolo_carrington = solo_inertial.transform_to(\n    sunpy.coordinates.HeliographicCarrington(observer=\"self\")\n)\n</pre> ### Create SkyCoord for Orbiter in the inertial (J2000) frame solo_inertial = astrospice.generate_coords(     'SOLAR ORBITER', pd.to_datetime(merged_df.index.to_list())  )  ### Transform to solar co-rotating frame  solo_carrington = solo_inertial.transform_to(     sunpy.coordinates.HeliographicCarrington(observer=\"self\") ) <p>Now we will add the position information to our merged dataframe and save as a CSV file!</p> In\u00a0[23]: Copied! <pre>### ADD POSITION INFORMAITON AND SAVE\norbiter = merged_df.copy()\norbiter['lon'] = solo_carrington.lon.value\norbiter['lat'] = solo_carrington.lat.value\norbiter['rAU'] = solo_carrington.radius.to(u.AU).value\norbiter['NpR2'] = orbiter.Np * (orbiter.rAU ** 2)\norbiter['BrR2'] = orbiter.Br * (orbiter.rAU ** 2)\norbiter.to_csv(os.path.join('results', 'orbiter.csv'))\norbiter\n</pre> ### ADD POSITION INFORMAITON AND SAVE orbiter = merged_df.copy() orbiter['lon'] = solo_carrington.lon.value orbiter['lat'] = solo_carrington.lat.value orbiter['rAU'] = solo_carrington.radius.to(u.AU).value orbiter['NpR2'] = orbiter.Np * (orbiter.rAU ** 2) orbiter['BrR2'] = orbiter.Br * (orbiter.rAU ** 2) orbiter.to_csv(os.path.join('results', 'orbiter.csv')) orbiter Out[23]: FeO C6C4 O7O6 vr vt vn Np Tp Br Bt Bn lon lat rAU NpR2 BrR2 Time 2022-02-28 00:00:06.789 0.124352 4.666133 0.155761 424.744781 19.354290 9.476597 15.910052 14.443886 NaN NaN NaN 88.846704 -3.953242 0.588543 5.510963 NaN 2022-02-28 00:10:06.790 0.143489 4.374543 0.132367 430.309509 -10.409559 4.992716 15.175641 13.325876 8.347488 0.860707 -5.480343 88.762049 -3.953671 0.588459 5.255083 2.890602 2022-02-28 06:40:08.304 0.087948 5.567347 0.157014 403.868774 -2.350639 -11.650457 14.210595 12.659678 7.465621 2.410246 1.980348 85.463394 -3.970309 0.585193 4.866437 2.556611 2022-02-28 06:50:08.308 0.096935 5.883932 0.116356 404.171631 9.492729 -8.537971 14.608211 12.434838 7.570980 -3.244457 0.379171 85.378898 -3.970733 0.585110 5.001167 2.591949 2022-02-28 07:00:08.307 0.088331 5.510294 0.152262 405.851929 -1.856772 -0.798619 14.604689 13.610792 8.389572 1.017700 -0.502235 85.294407 -3.971157 0.585026 4.998528 2.871373 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 2022-03-03 23:12:35.832 0.177951 0.806852 0.030863 534.060486 -52.871349 -16.808073 12.657435 43.209732 -7.727091 -2.800273 -14.610142 41.199120 -4.174650 0.539771 3.687772 -2.251305 2022-03-03 23:22:35.834 0.186515 1.020882 0.043776 553.383423 -22.988846 -29.223343 12.831614 45.184616 -4.232800 8.969854 -11.212367 41.117091 -4.174984 0.539684 3.737315 -1.232838 2022-03-03 23:32:35.837 0.199694 1.263365 0.042423 512.782776 -59.263123 -24.667286 11.267587 40.657085 -9.783181 -2.474164 -11.849442 41.035067 -4.175318 0.539597 3.280721 -2.848515 2022-03-03 23:42:35.838 0.152551 1.257348 0.036182 525.783875 -18.417173 -25.256227 12.530423 41.655029 -2.001657 13.037391 -4.190036 40.953048 -4.175652 0.539510 3.647239 -0.582624 2022-03-03 23:52:35.841 0.147041 0.979760 0.030283 522.942627 6.084055 -20.665825 14.348630 34.095783 -8.526532 6.925846 -9.869720 40.871035 -4.175985 0.539423 4.175119 -2.481024 <p>497 rows \u00d7 16 columns</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/docs_orbiter/#solar-orbiter-data-aquisition","title":"Solar Orbiter Data Aquisition\u00b6","text":"<p>Based on the sunpy-soar package by Laura Hayes.</p> <p>Some useful links:</p> <ul> <li>An introduction to SunPy https://docs.sunpy.org/en/stable/tutorial/index.html</li> <li>Solar Orbiter Archive https://soar.esac.esa.int/soar/</li> <li>Summary of SOOPs that have been run: https://www.cosmos.esa.int/web/solar-orbiter/soops-summary</li> <li>Inventory plots of data on SOAR: https://www.cosmos.esa.int/web/soar/inventory-plots</li> <li>STIX data center: https://datacenter.stix.i4ds.net/stix</li> <li>EUI/SIDC Solar Eruption list: https://www.sidc.be/EUI/solar-eruptions</li> <li>EPD data loader: https://github.com/jgieseler/solo-epd-loader</li> </ul>"},{"location":"examples/docs_orbiter/#access-and-download-solar-orbiter-data-with-sunpy","title":"Access and download Solar Orbiter data with Sunpy\u00b6","text":""},{"location":"examples/docs_orbiter/#lets-construct-a-query","title":"Lets construct a query\u00b6","text":"<p>To search for data with Fido, you need to specify attributes to search with. These are usually a timerange (<code>a.Time</code>), and an instrument (<code>a.Instrument</code>). But you can also add lots of different attributes to make your query more specific. It should also be noted that Fido will return all possible results given the conditions of your query, so for example, if two data providers host the same data, it will return two results (for example the VSO provides the EUI data as well as the SOAR). You can also specifiy the provider you want to search for in your query.</p>"},{"location":"examples/docs_orbiter/#then-to-download-the-files-you-can-use-fidofetch","title":"Then to download the files, you can use <code>Fido.fetch</code>\u00b6","text":"<p>Now that we have located the files were interested in via a <code>Fido.search</code>, we can download them via <code>Fido.fetch</code>. You pass your query results from <code>Fido.search</code> to the <code>.fetch</code>. You can also specifiy the path for which to save them locally. Here we save them in the same structure as pySPEDAS.</p>"},{"location":"examples/docs_orbiter/#create-orbiter-magswa-dataframe","title":"Create Orbiter MAG/SWA Dataframe\u00b6","text":"<p>We will create a pandas dataframe for each instrument, this is easier to use for plotting/science purposes. We then use pandas to merge the dataframes as a function of time.</p>"},{"location":"examples/docs_orbiter/#find-the-spacecraft-trajectory","title":"Find the spacecraft trajectory\u00b6","text":"<p>Now we will use astrospice to generate the trajectory of the spacecraft. We transform from inertial coordinates to the solar co-rotating (Carrington) frame!</p>"},{"location":"examples/docs_parker/","title":"Parker Data","text":"In\u00a0[9]: Copied! <pre>import pyspedas\nfrom pyspedas import time_string\nfrom pytplot import tplot, get_data\nimport astrospice\nimport sunpy \nimport sunpy.coordinates as scoords\nimport sys, os\nimport datetime\nimport pandas as pd\nimport astropy.units as u\nimport matplotlib.pyplot as plt\n\nfor sc in ['psp','solar orbiter'] : kernels = astrospice.registry.get_kernels(sc,'predict')\n</pre>  import pyspedas from pyspedas import time_string from pytplot import tplot, get_data import astrospice import sunpy  import sunpy.coordinates as scoords import sys, os import datetime import pandas as pd import astropy.units as u import matplotlib.pyplot as plt  for sc in ['psp','solar orbiter'] : kernels = astrospice.registry.get_kernels(sc,'predict')   <pre>Files Downloaded:   0%|          | 0/1 [00:00&lt;?, ?file/s]</pre> <pre>03-Nov-23 12:52:08: sys:1: ResourceWarning: Unclosed socket &lt;zmq.Socket(zmq.PUSH) at 0x17dcca400&gt;\n\n03-Nov-23 12:52:09: /Users/tamarervin/anaconda3/envs/psp38/lib/python3.8/asyncio/base_events.py:654: ResourceWarning: unclosed event loop &lt;_UnixSelectorEventLoop running=False closed=False debug=False&gt;\n  _warn(f\"unclosed event loop {self!r}\", ResourceWarning, source=self)\n\n03-Nov-23 12:52:09: /Users/tamarervin/anaconda3/envs/psp38/lib/python3.8/site-packages/erfa/core.py:154: ErfaWarning: ERFA function \"dtf2d\" yielded 1 of \"dubious year (Note 6)\"\n  warnings.warn('ERFA function \"{}\" yielded {}'.format(func_name, wmsg),\n\n</pre> <pre>Files Downloaded:   0%|          | 0/1 [00:00&lt;?, ?file/s]</pre> <pre>03-Nov-23 12:52:09: sys:1: ResourceWarning: Unclosed socket &lt;zmq.Socket(zmq.PUSH) at 0x168ae64c0&gt;\n\n</pre> In\u00a0[2]: Copied! <pre>### ------- TIME PERIOD OF INTEREST ------- ###\n# this is an example of data from the heliospheric current sheet (HCS) crossing during PSP Encounter 15\ntime_range = ['2023-03-17/12:00', '2023-03-18/12:00']\n</pre> ### ------- TIME PERIOD OF INTEREST ------- ### # this is an example of data from the heliospheric current sheet (HCS) crossing during PSP Encounter 15 time_range = ['2023-03-17/12:00', '2023-03-18/12:00'] In\u00a0[3]: Copied! <pre>### ------- FIELDS: MAG RTN DATA ------- ###\nfields_vars = pyspedas.psp.fields(trange=time_range, datatype='mag_RTN_4_Sa_per_Cyc')\n\n### print out the variables stored in the magnetic field data\nprint(fields_vars)\n\n### get the RTN magnetic field\nB_RTN = get_data('psp_fld_l2_mag_RTN_4_Sa_per_Cyc')\n\n### plot the data!\ntplot(['psp_fld_l2_mag_RTN_4_Sa_per_Cyc'])\n\n### CONVERT TIME FROM JULIAN TIME TO DATETIME OBJECT\ndate_obj = [datetime.datetime.strptime(time_string(d), '%Y-%m-%d %H:%M:%S.%f') for d in B_RTN.times]\n\n### CREATE DATAFRAME\nrd = {'Time': date_obj, 'Br': B_RTN.y[:, 0], 'Bt': B_RTN.y[:, 1], 'Bn': B_RTN.y[:, 2]}\nfields = pd.DataFrame(data=rd)\n\n### SAVE DATAFRAME AS CSV\nfields.to_csv(os.path.join('results', 'fields.csv'))\n</pre> ### ------- FIELDS: MAG RTN DATA ------- ### fields_vars = pyspedas.psp.fields(trange=time_range, datatype='mag_RTN_4_Sa_per_Cyc')  ### print out the variables stored in the magnetic field data print(fields_vars)  ### get the RTN magnetic field B_RTN = get_data('psp_fld_l2_mag_RTN_4_Sa_per_Cyc')  ### plot the data! tplot(['psp_fld_l2_mag_RTN_4_Sa_per_Cyc'])  ### CONVERT TIME FROM JULIAN TIME TO DATETIME OBJECT date_obj = [datetime.datetime.strptime(time_string(d), '%Y-%m-%d %H:%M:%S.%f') for d in B_RTN.times]  ### CREATE DATAFRAME rd = {'Time': date_obj, 'Br': B_RTN.y[:, 0], 'Bt': B_RTN.y[:, 1], 'Bn': B_RTN.y[:, 2]} fields = pd.DataFrame(data=rd)  ### SAVE DATAFRAME AS CSV fields.to_csv(os.path.join('results', 'fields.csv'))  <pre>03-Nov-23 12:49:57: Downloading remote index: https://spdf.gsfc.nasa.gov/pub/data/psp/fields/l2/mag_rtn_4_per_cycle/2023/\n03-Nov-23 12:49:58: File is current: psp_data/fields/l2/mag_rtn_4_per_cycle/2023/psp_fld_l2_mag_rtn_4_sa_per_cyc_20230317_v02.cdf\n03-Nov-23 12:49:58: File is current: psp_data/fields/l2/mag_rtn_4_per_cycle/2023/psp_fld_l2_mag_rtn_4_sa_per_cyc_20230318_v02.cdf\n03-Nov-23 12:50:00: Downloading remote index: https://spdf.gsfc.nasa.gov/pub/data/psp/fields/l2/mag_rtn_4_per_cycle/2023/\n03-Nov-23 12:50:01: File is current: psp_data/fields/l2/mag_rtn_4_per_cycle/2023/psp_fld_l2_mag_rtn_4_sa_per_cyc_20230317_v02.cdf\n03-Nov-23 12:50:01: File is current: psp_data/fields/l2/mag_rtn_4_per_cycle/2023/psp_fld_l2_mag_rtn_4_sa_per_cyc_20230318_v02.cdf\n03-Nov-23 12:50:01: /Users/tamarervin/anaconda3/envs/psp38/lib/python3.8/asyncio/base_events.py:654: ResourceWarning: unclosed event loop &lt;_UnixSelectorEventLoop running=False closed=False debug=False&gt;\n  _warn(f\"unclosed event loop {self!r}\", ResourceWarning, source=self)\n\n</pre> <pre>['psp_fld_l2_mag_RTN_4_Sa_per_Cyc', 'psp_fld_l2_quality_flags']\n</pre> In\u00a0[4]: Copied! <pre>### ------- SPAN-I: PROTON (HYDROGEN) MOMENTS ------- ###\n### download proton data\nproton_vars = pyspedas.psp.spi(trange=time_range, datatype='sf00_l3_mom', level='l3')\n\n### print out the variables stored in the proton data\nprint(proton_vars)\n\n### get the RTN velocity, density, and temperature\nNp = get_data('psp_spi_DENS')\nvp_RTN = get_data('psp_spi_VEL_RTN_SUN')\nTp = get_data('psp_spi_TEMP')\n\n### CONVERT TIME FROM JULIAN TIME TO DATETIME OBJECT\ndate_obj = [datetime.datetime.strptime(time_string(d), '%Y-%m-%d %H:%M:%S.%f') for d in Np.times]\n\n### CREATE DATAFRAME\nrd = {'Time': date_obj, 'vr': vp_RTN.y[:, 0], 'vt': vp_RTN.y[:, 1], 'vn': vp_RTN.y[:, 2], 'Np': Np.y, 'Tp': Tp.y}\nprotons = pd.DataFrame(data=rd)\n\n### SAVE DATAFRAME AS CSV\nprotons.to_csv(os.path.join('results', 'protons.csv'))\n\n### plot the data!\ntplot(['psp_spi_DENS', 'psp_spi_VEL_RTN_SUN', 'psp_spi_TEMP'])\n</pre> ### ------- SPAN-I: PROTON (HYDROGEN) MOMENTS ------- ### ### download proton data proton_vars = pyspedas.psp.spi(trange=time_range, datatype='sf00_l3_mom', level='l3')  ### print out the variables stored in the proton data print(proton_vars)  ### get the RTN velocity, density, and temperature Np = get_data('psp_spi_DENS') vp_RTN = get_data('psp_spi_VEL_RTN_SUN') Tp = get_data('psp_spi_TEMP')  ### CONVERT TIME FROM JULIAN TIME TO DATETIME OBJECT date_obj = [datetime.datetime.strptime(time_string(d), '%Y-%m-%d %H:%M:%S.%f') for d in Np.times]  ### CREATE DATAFRAME rd = {'Time': date_obj, 'vr': vp_RTN.y[:, 0], 'vt': vp_RTN.y[:, 1], 'vn': vp_RTN.y[:, 2], 'Np': Np.y, 'Tp': Tp.y} protons = pd.DataFrame(data=rd)  ### SAVE DATAFRAME AS CSV protons.to_csv(os.path.join('results', 'protons.csv'))  ### plot the data! tplot(['psp_spi_DENS', 'psp_spi_VEL_RTN_SUN', 'psp_spi_TEMP']) <pre>03-Nov-23 12:50:46: Downloading remote index: https://spdf.gsfc.nasa.gov/pub/data/psp/sweap/spi/l3/spi_sf00_l3_mom/2023/\n</pre> <pre>Using LEVEL=L3\n</pre> <pre>03-Nov-23 12:50:47: File is current: psp_data/sweap/spi/l3/spi_sf00_l3_mom/2023/psp_swp_spi_sf00_l3_mom_20230317_v04.cdf\n03-Nov-23 12:50:48: File is current: psp_data/sweap/spi/l3/spi_sf00_l3_mom/2023/psp_swp_spi_sf00_l3_mom_20230318_v04.cdf\n</pre> <pre>['psp_spi_QUALITY_FLAG', 'psp_spi_DENS', 'psp_spi_VEL_INST', 'psp_spi_VEL_SC', 'psp_spi_VEL_RTN_SUN', 'psp_spi_T_TENSOR_INST', 'psp_spi_TEMP', 'psp_spi_EFLUX_VS_ENERGY', 'psp_spi_EFLUX_VS_THETA', 'psp_spi_EFLUX_VS_PHI', 'psp_spi_SUN_DIST', 'psp_spi_VENUS_DIST', 'psp_spi_SC_VEL_RTN_SUN', 'psp_spi_QUAT_SC_TO_RTN', 'psp_spi_MAGF_SC', 'psp_spi_MAGF_INST']\n</pre> In\u00a0[5]: Copied! <pre>### ------- SPAN-I: ALPHA PARTICLE (HELIUM) MOMENTS ------- ###\n### download alpha particle data\nalpha_vars = pyspedas.psp.spi(trange=time_range, datatype='sf0a_l3_mom', level='l3')\n\n### print out the variables stored in the alpha particle data\nprint(alpha_vars)\n\n### READ IN SWEAP VELOCITY (RTN), DENSITY, AND TEMPERATURE DATA\nNa = get_data('psp_spi_DENS')\nva_RTN = get_data('psp_spi_VEL_RTN_SUN')\nTa = get_data('psp_spi_TEMP')\n\n### CONVERT TIME FROM JULIAN TIME TO DATETIME OBJECT\ndate_obj = [datetime.datetime.strptime(time_string(d), '%Y-%m-%d %H:%M:%S.%f') for d in Na.times]\n\n### CREATE DATAFRAME\nrd = {'Time': date_obj, 'vr': va_RTN.y[:, 0], 'vt': va_RTN.y[:, 1], 'vn': va_RTN.y[:, 2], 'Na': Na.y, 'Ta': Ta.y}\nalphas = pd.DataFrame(data=rd)\n\n### SAVE DATAFRAME AS CSV\nalphas.to_csv(os.path.join('results', 'alphas.csv'))\n\n### plot the data!\ntplot(['psp_spi_DENS', 'psp_spi_VEL_RTN_SUN', 'psp_spi_TEMP'])\n</pre> ### ------- SPAN-I: ALPHA PARTICLE (HELIUM) MOMENTS ------- ### ### download alpha particle data alpha_vars = pyspedas.psp.spi(trange=time_range, datatype='sf0a_l3_mom', level='l3')  ### print out the variables stored in the alpha particle data print(alpha_vars)  ### READ IN SWEAP VELOCITY (RTN), DENSITY, AND TEMPERATURE DATA Na = get_data('psp_spi_DENS') va_RTN = get_data('psp_spi_VEL_RTN_SUN') Ta = get_data('psp_spi_TEMP')  ### CONVERT TIME FROM JULIAN TIME TO DATETIME OBJECT date_obj = [datetime.datetime.strptime(time_string(d), '%Y-%m-%d %H:%M:%S.%f') for d in Na.times]  ### CREATE DATAFRAME rd = {'Time': date_obj, 'vr': va_RTN.y[:, 0], 'vt': va_RTN.y[:, 1], 'vn': va_RTN.y[:, 2], 'Na': Na.y, 'Ta': Ta.y} alphas = pd.DataFrame(data=rd)  ### SAVE DATAFRAME AS CSV alphas.to_csv(os.path.join('results', 'alphas.csv'))  ### plot the data! tplot(['psp_spi_DENS', 'psp_spi_VEL_RTN_SUN', 'psp_spi_TEMP']) <pre>03-Nov-23 12:50:57: Downloading remote index: https://spdf.gsfc.nasa.gov/pub/data/psp/sweap/spi/l3/spi_sf0a_l3_mom/2023/\n</pre> <pre>Using LEVEL=L3\n</pre> <pre>03-Nov-23 12:50:58: File is current: psp_data/sweap/spi/l3/spi_sf0a_l3_mom/2023/psp_swp_spi_sf0a_l3_mom_20230317_v04.cdf\n03-Nov-23 12:50:58: File is current: psp_data/sweap/spi/l3/spi_sf0a_l3_mom/2023/psp_swp_spi_sf0a_l3_mom_20230318_v04.cdf\n</pre> <pre>['psp_spi_QUALITY_FLAG', 'psp_spi_DENS', 'psp_spi_VEL_INST', 'psp_spi_VEL_SC', 'psp_spi_VEL_RTN_SUN', 'psp_spi_T_TENSOR_INST', 'psp_spi_TEMP', 'psp_spi_EFLUX_VS_ENERGY', 'psp_spi_EFLUX_VS_THETA', 'psp_spi_EFLUX_VS_PHI', 'psp_spi_SUN_DIST', 'psp_spi_VENUS_DIST', 'psp_spi_SC_VEL_RTN_SUN', 'psp_spi_QUAT_SC_TO_RTN', 'psp_spi_MAGF_SC', 'psp_spi_MAGF_INST']\n</pre> In\u00a0[6]: Copied! <pre>### merge the PAS and MAG dataframes\nmerged_df = pd.merge_asof(fields, protons, on='Time', direction='backward')\n\n### merge the HIS and newly merged dataframe\nmerged_df = pd.merge_asof(alphas, merged_df, on='Time', direction='backward')\nmerged_df = merged_df.set_index('Time')\n</pre> ### merge the PAS and MAG dataframes merged_df = pd.merge_asof(fields, protons, on='Time', direction='backward')  ### merge the HIS and newly merged dataframe merged_df = pd.merge_asof(alphas, merged_df, on='Time', direction='backward') merged_df = merged_df.set_index('Time') In\u00a0[10]: Copied! <pre>### Create SkyCoord for Parker in the inertial (J2000) frame\npsp_inertial = astrospice.generate_coords(\n    'SOLAR PROBE PLUS', pd.to_datetime(merged_df.index.to_list())\n\n)\n\n### Transform to solar co-rotating frame \npsp_carrington = psp_inertial.transform_to(\n    scoords.HeliographicCarrington(observer=\"self\")\n)\n</pre> ### Create SkyCoord for Parker in the inertial (J2000) frame psp_inertial = astrospice.generate_coords(     'SOLAR PROBE PLUS', pd.to_datetime(merged_df.index.to_list())  )  ### Transform to solar co-rotating frame  psp_carrington = psp_inertial.transform_to(     scoords.HeliographicCarrington(observer=\"self\") ) <p>Now we will add the position information to our merged dataframe and save as a CSV file!</p> In\u00a0[11]: Copied! <pre>### ADD POSITION INFORMAITON AND SAVE\nparker = merged_df.copy()\nparker['lon'] = psp_carrington.lon.value\nparker['lat'] = psp_carrington.lat.value\nparker['rAU'] = psp_carrington.radius.to(u.AU).value\nparker['NpR2'] = parker.Np * (parker.rAU ** 2)\nparker['BrR2'] = parker.Br * (parker.rAU ** 2)\nparker.to_csv(os.path.join('results', 'parker.csv'))\nparker\n</pre> ### ADD POSITION INFORMAITON AND SAVE parker = merged_df.copy() parker['lon'] = psp_carrington.lon.value parker['lat'] = psp_carrington.lat.value parker['rAU'] = psp_carrington.radius.to(u.AU).value parker['NpR2'] = parker.Np * (parker.rAU ** 2) parker['BrR2'] = parker.Br * (parker.rAU ** 2) parker.to_csv(os.path.join('results', 'parker.csv')) parker Out[11]: vr_x vt_x vn_x Na Ta Br Bt Bn vr_y vt_y vn_y Np Tp lon lat rAU NpR2 BrR2 Time 2023-03-17 00:00:03.869595 136.413834 -66.148483 49.722652 0.388385 -0.000087 -460.497559 66.652130 25.975363 NaN NaN NaN NaN NaN 5.436847 -0.599451 0.081274 NaN -3.041764 2023-03-17 00:00:07.364835 NaN NaN NaN 0.000000 NaN -460.015228 73.225525 21.024397 216.121811 -8.346628 31.184471 72.195038 41.848660 5.438309 -0.599587 0.081272 0.476858 -3.038463 2023-03-17 00:00:10.860136 NaN NaN NaN 0.000000 NaN -461.111633 69.096474 14.254626 201.977798 -8.060006 15.134486 83.939156 41.792698 5.439771 -0.599723 0.081270 0.554408 -3.045589 2023-03-17 00:00:14.355377 NaN NaN NaN 0.000000 NaN -463.271484 45.696793 24.873411 204.622040 -2.734370 -8.305954 83.250435 47.484131 5.441233 -0.599858 0.081269 0.549839 -3.059739 2023-03-17 00:00:17.850618 213.295364 8.470299 84.349762 0.307426 -0.000088 -463.071014 45.171581 26.641287 208.022537 -24.612598 27.923014 88.809814 46.484776 5.442695 -0.599994 0.081267 0.586534 -3.058299 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 2023-03-18 23:59:45.415700 467.251678 -119.165878 4.757739 56.570091 499.240814 323.541870 117.854416 -40.503208 316.523438 -80.164185 51.505405 1178.158325 62.458263 112.948472 -2.228309 0.092909 10.169938 2.792834 2023-03-18 23:59:48.910940 464.533112 -115.335388 -0.120976 52.530193 589.464417 344.583527 48.452587 -47.286186 317.690277 -102.556511 35.999821 1232.727661 65.334381 112.949459 -2.228223 0.092911 10.641370 2.974575 2023-03-18 23:59:52.406241 480.955933 -100.031128 12.107570 50.822128 488.711578 323.028778 136.430649 -9.331066 310.887329 -84.589439 31.938829 1196.579346 63.912716 112.950445 -2.228137 0.092912 10.329698 2.788607 2023-03-18 23:59:55.901482 492.865723 -126.695915 21.139906 62.649345 473.030762 323.584839 119.636749 -75.996742 323.035309 -118.320900 53.034309 1195.040039 65.877647 112.951431 -2.228051 0.092914 10.316784 2.793509 2023-03-18 23:59:59.396723 NaN NaN NaN NaN NaN 286.590302 182.615662 -59.358253 341.417572 -144.636108 49.197903 1231.612793 69.274925 112.952418 -2.227965 0.092916 10.632902 2.474225 <p>78724 rows \u00d7 18 columns</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/docs_parker/#parker-solar-probe-data-download-example","title":"Parker Solar Probe Data Download Example\u00b6","text":"<p>Tamar Ervin</p> <ul> <li>Downloading PSP data with PySPEDAS</li> <li>Using pyTplot to plot the data</li> </ul>"},{"location":"examples/docs_parker/#download-and-plot-the-data","title":"Download and Plot the Data\u00b6","text":"<p>Example data to download:</p> <ul> <li>FIELDS: Radial, Tangential, Normal (RTN) magnetic field data</li> <li>SWEAP/SPAN-I Proton: Radial, Tangential, Normal (RTN) proton velocity and proton density data</li> <li>SWEAP/SPAN-I Alpha Particle: Radial, Tangential, Normal (RTN) alpha particle velocity and density</li> </ul> <p>Data will download to a folder titled 'psp_data' in this same repo!</p> <p>Don't worry if this takes a while to run! The data is at a very high cadence and takes a bit to download depending on the time range</p>"},{"location":"examples/docs_parker/#plot-the-data-using-pytplot","title":"Plot the data using pyTplot\u00b6","text":"<p>pyTplot is a Python package that works with PySPEDAS to plot space physics data! It already has all the information needed to plot observables in terms of their units! You can also create your own plots of the data using matplotlib.</p>"},{"location":"examples/docs_parker/#create-parker-fieldssweap-dataframe","title":"Create Parker FIELDS/SWEAP Dataframe\u00b6","text":"<p>Now that we have a dataframe for each instrument, we then use pandas to merge the dataframes as a function of time.</p>"},{"location":"examples/docs_parker/#find-the-spacecraft-trajectory","title":"Find the spacecraft trajectory\u00b6","text":"<p>Now we will use astrospice to generate the trajectory of the spacecraft. We transform from inertial coordinates to the solar co-rotating (Carrington) frame!</p>"},{"location":"examples/docs_sdo/","title":"Sunpy Basics","text":"In\u00a0[10]: Copied! <pre>import numpy as np\n\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport matplotlib.colors as colors\n\nimport astropy.units as u\n\nimport sunpy.map\nfrom sunpy.net import Fido\nfrom sunpy.net import attrs as a\nimport sunpy.visualization.colormaps as cm\n</pre> import numpy as np  import matplotlib.pyplot as plt import matplotlib.animation as animation import matplotlib.colors as colors  import astropy.units as u  import sunpy.map from sunpy.net import Fido from sunpy.net import attrs as a import sunpy.visualization.colormaps as cm <p>To download the required data, we use <code>sunpy.net.Fido</code>, a downloader client, to query the Virtual Solar Observatory to acquire AIA and HMI data.</p> <p>The following is the data available:</p> <p>HMI Bands (A): 171 (gold), 193 (bronze), 304 (red), 211 (purple), 131 (teal), 335 (blue), 094 (green), 1600 (yellow/green), 1700 (pink)</p> <p>HMI Products: Magnetogram, Intensitygram, Dopplergram</p> In\u00a0[11]: Copied! <pre># data parameters\ncadence = a.Sample(24*u.hour)  # querying cadence\nstart_date = '2021-1-1T12:00:00'  # start date of query\nend_date = '2021-01-5T12:00:00'  # end date of query\n\n# AIA specific parameters\naia_inst = a.Instrument.aia\n# list of all available wavelengths for reference\nwavelength_list = [a.Wavelength(94 * u.angstrom), a.Wavelength(131 * u.angstrom), a.Wavelength(171 * u.angstrom),\n                   a.Wavelength(193 * u.angstrom), a.Wavelength(211 * u.angstrom), a.Wavelength(304 * u.angstrom),\n                   a.Wavelength(335 * u.angstrom), a.Wavelength(1600 * u.angstrom), a.Wavelength(1700 * u.angstrom)]\n\n# HMI specific parameters\nhmi_inst = a.Instrument.hmi\n# list of physical observables available\nphysobs_list = [a.Physobs.los_velocity, a.Physobs.los_magnetic_field, a.Physobs.intensity]\n</pre> # data parameters cadence = a.Sample(24*u.hour)  # querying cadence start_date = '2021-1-1T12:00:00'  # start date of query end_date = '2021-01-5T12:00:00'  # end date of query  # AIA specific parameters aia_inst = a.Instrument.aia # list of all available wavelengths for reference wavelength_list = [a.Wavelength(94 * u.angstrom), a.Wavelength(131 * u.angstrom), a.Wavelength(171 * u.angstrom),                    a.Wavelength(193 * u.angstrom), a.Wavelength(211 * u.angstrom), a.Wavelength(304 * u.angstrom),                    a.Wavelength(335 * u.angstrom), a.Wavelength(1600 * u.angstrom), a.Wavelength(1700 * u.angstrom)]  # HMI specific parameters hmi_inst = a.Instrument.hmi # list of physical observables available physobs_list = [a.Physobs.los_velocity, a.Physobs.los_magnetic_field, a.Physobs.intensity] <p>Now we can look at querying for specific information. We can look for results from multiple instruments, wavelengths, and physical observables at once.</p> <p>It is useful to search for results before download to ensure you don't download excessive amounts of data.</p> <p>Let's say we only want these specific results from AIA. We search for images at a 24 hour cadence between our start and end times at specified wavelengths.</p> In\u00a0[12]: Copied! <pre>aia_result = Fido.search(a.Time(start_date, end_date),\n                     aia_inst, wavelength_list[0]  | wavelength_list[2] | wavelength_list[3]\n                     | wavelength_list[6], cadence)\n</pre> aia_result = Fido.search(a.Time(start_date, end_date),                      aia_inst, wavelength_list[0]  | wavelength_list[2] | wavelength_list[3]                      | wavelength_list[6], cadence) <p>We can do the same with HMI data products.</p> In\u00a0[13]: Copied! <pre>hmi_result = Fido.search(a.Time(start_date, end_date),\n                     a.Instrument.hmi, physobs_list[0] | physobs_list[1] | physobs_list[2], cadence)\n</pre> hmi_result = Fido.search(a.Time(start_date, end_date),                      a.Instrument.hmi, physobs_list[0] | physobs_list[1] | physobs_list[2], cadence)  <p>You can also query for both instruments simultaneously.</p> In\u00a0[14]: Copied! <pre>result = Fido.search(a.Time(start_date, end_date),\n                     aia_inst | hmi_inst, wavelength_list[0] | wavelength_list[1] | wavelength_list[2] | wavelength_list[3]\n                     | wavelength_list[4] | wavelength_list[5] | wavelength_list[6] | wavelength_list[7] | wavelength_list[8]\n                     | physobs_list[0] | physobs_list[1] | physobs_list[2],\n                     cadence)\n</pre> result = Fido.search(a.Time(start_date, end_date),                      aia_inst | hmi_inst, wavelength_list[0] | wavelength_list[1] | wavelength_list[2] | wavelength_list[3]                      | wavelength_list[4] | wavelength_list[5] | wavelength_list[6] | wavelength_list[7] | wavelength_list[8]                      | physobs_list[0] | physobs_list[1] | physobs_list[2],                      cadence) <pre>/Users/tervin/opt/anaconda3/envs/neid_data/lib/python3.7/site-packages/astropy/table/table.py:3197: FutureWarning: elementwise == comparison failed and returning scalar instead; this will raise an error or perform elementwise comparison in the future.\n  result = self.as_array() == other\n</pre> <p>Next we download the actual data found from our search.</p> In\u00a0[15]: Copied! <pre>file_download = Fido.fetch(result)\n</pre>  file_download = Fido.fetch(result)  <pre>Files Downloaded:   0%|          | 0/54 [00:00&lt;?, ?file/s]</pre> <p>After downloading our data, we want to sort it by date. We then build a map sequence of our data.</p> In\u00a0[16]: Copied! <pre>map_seq = sunpy.map.Map(sorted(file_download))\n</pre> map_seq = sunpy.map.Map(sorted(file_download))  <p>We then split our results by data product.</p> In\u00a0[17]: Copied! <pre>aia_094, aia_131, aia_171, aia_193, aia_211, aia_304, aia_335, aia_1600, aia_1700, hmi_vel, hmi_mag, hmi_int \\\n    = [], [], [], [], [], [], [], [], [], [], [], []\n\nfor i, map_obj in enumerate(map_seq):\n    if map_obj.meta['wavelnth'] == 94:\n        aia_094.append(map_obj)\n    elif map_obj.meta['wavelnth'] == 131:\n        aia_131.append(map_obj)\n    elif map_obj.meta['wavelnth'] == 171:\n        aia_171.append(map_obj)\n    elif map_obj.meta['wavelnth'] == 193:\n        aia_193.append(map_obj)\n    elif map_obj.meta['wavelnth'] == 211:\n        aia_211.append(map_obj)\n    elif map_obj.meta['wavelnth'] == 304:\n        aia_304.append(map_obj)\n    elif map_obj.meta['wavelnth'] == 335:\n        aia_335.append(map_obj)\n    elif map_obj.meta['wavelnth'] == 1600:\n        aia_1600.append(map_obj)\n    elif map_obj.meta['wavelnth'] == 1700:\n        aia_1700.append(map_obj)\n    elif map_obj.meta['wavelnth'] == 6173 and map_obj.meta['content'] == 'DOPPLERGRAM':\n        hmi_vel.append(map_obj)\n    elif map_obj.meta['wavelnth'] == 6173 and map_obj.meta['content'] == 'MAGNETOGRAM':\n        hmi_mag.append(map_obj)\n    elif map_obj.meta['wavelnth'] == 6173 and map_obj.meta['content'] == 'CONTINUUM INTENSITY':\n        hmi_int.append(map_obj)\n</pre> aia_094, aia_131, aia_171, aia_193, aia_211, aia_304, aia_335, aia_1600, aia_1700, hmi_vel, hmi_mag, hmi_int \\     = [], [], [], [], [], [], [], [], [], [], [], []  for i, map_obj in enumerate(map_seq):     if map_obj.meta['wavelnth'] == 94:         aia_094.append(map_obj)     elif map_obj.meta['wavelnth'] == 131:         aia_131.append(map_obj)     elif map_obj.meta['wavelnth'] == 171:         aia_171.append(map_obj)     elif map_obj.meta['wavelnth'] == 193:         aia_193.append(map_obj)     elif map_obj.meta['wavelnth'] == 211:         aia_211.append(map_obj)     elif map_obj.meta['wavelnth'] == 304:         aia_304.append(map_obj)     elif map_obj.meta['wavelnth'] == 335:         aia_335.append(map_obj)     elif map_obj.meta['wavelnth'] == 1600:         aia_1600.append(map_obj)     elif map_obj.meta['wavelnth'] == 1700:         aia_1700.append(map_obj)     elif map_obj.meta['wavelnth'] == 6173 and map_obj.meta['content'] == 'DOPPLERGRAM':         hmi_vel.append(map_obj)     elif map_obj.meta['wavelnth'] == 6173 and map_obj.meta['content'] == 'MAGNETOGRAM':         hmi_mag.append(map_obj)     elif map_obj.meta['wavelnth'] == 6173 and map_obj.meta['content'] == 'CONTINUUM INTENSITY':         hmi_int.append(map_obj) <p>You can plot individual images using inherent Sunpy features.</p> In\u00a0[19]: Copied! <pre>aia_211[0].peek()  # this plots the aia image with a colorbar, axes labels, and title\n</pre> aia_211[0].peek()  # this plots the aia image with a colorbar, axes labels, and title In\u00a0[20]: Copied! <pre>aia_211[0].plot()  # this just plots the data, allows you to customize labels, colormap, and title\nplt.show()\n</pre> aia_211[0].plot()  # this just plots the data, allows you to customize labels, colormap, and title plt.show() <p>Plotting HMI images requires us to rotate the image to match the orientation of AIA images.</p> <p>The same peek and plot methods work for HMI images.</p> In\u00a0[21]: Copied! <pre>hmi_vel_rot = hmi_vel[0].rotate(order=3)\nhmi_vel_rot.peek()\n</pre> hmi_vel_rot = hmi_vel[0].rotate(order=3) hmi_vel_rot.peek() <p>HMI images look nicer when customized a bit.</p> In\u00a0[22]: Copied! <pre># plotting intensity map\n\nint_map = hmi_int[0].rotate(order=3)\nint_map.plot_settings['cmap'] = plt.get_cmap('hinodesotintensity')\nint_map.plot()\nplt.show()\n</pre> # plotting intensity map  int_map = hmi_int[0].rotate(order=3) int_map.plot_settings['cmap'] = plt.get_cmap('hinodesotintensity') int_map.plot() plt.show()  In\u00a0[23]: Copied! <pre># plotting magnetic map\n\nmag_map = hmi_mag[0].rotate(order=3)\nmag_map.plot_settings['norm'] = plt.Normalize(-100, 100)\nmag_map.plot()\nplt.show()\n</pre> # plotting magnetic map  mag_map = hmi_mag[0].rotate(order=3) mag_map.plot_settings['norm'] = plt.Normalize(-100, 100) mag_map.plot() plt.show() In\u00a0[24]: Copied! <pre># plotting doppler map\n\nvel_map = hmi_vel[0].rotate(order=3)\nvel_map.plot_settings['norm'] = plt.Normalize(-5500, 5500)\nfig = plt.figure()\nvel_map.plot()\nplt.show()\n</pre> # plotting doppler map  vel_map = hmi_vel[0].rotate(order=3) vel_map.plot_settings['norm'] = plt.Normalize(-5500, 5500) fig = plt.figure() vel_map.plot() plt.show() <p>We can now make plots of multiple data types. Don't forget to rotate HMI images such that they are oriented the same as AIA.</p> In\u00a0[25]: Copied! <pre>fig, axs = plt.subplots(2, 2)\nfig.suptitle(\"Images %s\" % (str(aia_171[0].meta['t_obs'])))\naxs[0, 0].set_title(\"%s %s\" % (str(aia_171[0].meta['telescop']), str(aia_171[0].meta['wavelnth'])))\naxs[0, 1].set_title(\"%s %s\" % (str(aia_211[0].meta['telescop']), str(aia_211[0].meta['wavelnth'])))\naxs[1, 0].set_title(\"%s %s\" % (str(hmi_vel[0].meta['telescop']), str(hmi_vel[0].meta['content'])))\naxs[1, 1].set_title(\"%s %s\" % (str(hmi_mag[0].meta['telescop']), str(hmi_mag[0].meta['content'])))\n\nfor j in range(0, 2):\n    for k in range(0, 2):\n        axs[j, k].set_xticks([])\n        axs[j, k].set_yticks([])\n\naia_171[0].plot(axes=axs[0, 0], annotate=False)\naia_211[0].plot(axes=axs[0, 1], annotate=False)\n\n# make sure you rotate HMI images\nhmi_vel_rot = hmi_vel[0].rotate(order=3)\nhmi_vel_rot.plot(axes=axs[1, 0], annotate=False)\nhmi_mag_rot = hmi_mag[0].rotate(order=3)\nhmi_mag_rot.plot(axes=axs[1, 1], annotate=False)\n\nplt.show()\n</pre> fig, axs = plt.subplots(2, 2) fig.suptitle(\"Images %s\" % (str(aia_171[0].meta['t_obs']))) axs[0, 0].set_title(\"%s %s\" % (str(aia_171[0].meta['telescop']), str(aia_171[0].meta['wavelnth']))) axs[0, 1].set_title(\"%s %s\" % (str(aia_211[0].meta['telescop']), str(aia_211[0].meta['wavelnth']))) axs[1, 0].set_title(\"%s %s\" % (str(hmi_vel[0].meta['telescop']), str(hmi_vel[0].meta['content']))) axs[1, 1].set_title(\"%s %s\" % (str(hmi_mag[0].meta['telescop']), str(hmi_mag[0].meta['content'])))  for j in range(0, 2):     for k in range(0, 2):         axs[j, k].set_xticks([])         axs[j, k].set_yticks([])  aia_171[0].plot(axes=axs[0, 0], annotate=False) aia_211[0].plot(axes=axs[0, 1], annotate=False)  # make sure you rotate HMI images hmi_vel_rot = hmi_vel[0].rotate(order=3) hmi_vel_rot.plot(axes=axs[1, 0], annotate=False) hmi_mag_rot = hmi_mag[0].rotate(order=3) hmi_mag_rot.plot(axes=axs[1, 1], annotate=False)  plt.show() <pre>WARNING: SunpyUserWarning: The axes of this map are not aligned to the pixel grid. Plot axes may be incorrect. [sunpy.map.mapbase]\nWARNING: SunpyDeprecationWarning: WCSAxes not being used as the axes object for this plot. Support for this is deprecated, and will be removed in sunpy 3.1. To fix this pass set the `projection` keyword to this map when creating the axes. [sunpy.map.mapbase]\nWARNING: SunpyUserWarning: The axes of this map are not aligned to the pixel grid. Plot axes may be incorrect. [sunpy.map.mapbase]\nWARNING: SunpyDeprecationWarning: WCSAxes not being used as the axes object for this plot. Support for this is deprecated, and will be removed in sunpy 3.1. To fix this pass set the `projection` keyword to this map when creating the axes. [sunpy.map.mapbase]\nWARNING: SunpyUserWarning: The axes of this map are not aligned to the pixel grid. Plot axes may be incorrect. [sunpy.map.mapbase]\nWARNING: SunpyDeprecationWarning: WCSAxes not being used as the axes object for this plot. Support for this is deprecated, and will be removed in sunpy 3.1. To fix this pass set the `projection` keyword to this map when creating the axes. [sunpy.map.mapbase]\nWARNING: SunpyUserWarning: The axes of this map are not aligned to the pixel grid. Plot axes may be incorrect. [sunpy.map.mapbase]\nWARNING: SunpyDeprecationWarning: WCSAxes not being used as the axes object for this plot. Support for this is deprecated, and will be removed in sunpy 3.1. To fix this pass set the `projection` keyword to this map when creating the axes. [sunpy.map.mapbase]\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/docs_sdo/#examples-using-sunpy-for-querying-and-plotting","title":"Examples using Sunpy for querying and plotting\u00b6","text":""},{"location":"examples/docs_sdo/#querying-data","title":"Querying data\u00b6","text":""},{"location":"examples/docs_sdo/#plotting-images","title":"Plotting images\u00b6","text":""}]}